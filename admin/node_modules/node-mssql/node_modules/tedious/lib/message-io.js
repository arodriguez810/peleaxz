var _regeneratorRuntime = require('babel-runtime/regenerator').default;

// Generated by CoffeeScript 1.10.0
var EventEmitter,
    MessageIO,
    Packet,
    ReadablePacketStream,
    StreamParser,
    TYPE,
    crypto,
    isPacketComplete,
    packetHeaderLength,
    packetLength,
    tls,
    extend = function (child, parent) {
  for (var key in parent) {
    if (hasProp.call(parent, key)) child[key] = parent[key];
  }function ctor() {
    this.constructor = child;
  }ctor.prototype = parent.prototype;child.prototype = new ctor();child.__super__ = parent.prototype;return child;
},
    hasProp = ({}).hasOwnProperty,
    bind = function (fn, me) {
  return function () {
    return fn.apply(me, arguments);
  };
};

tls = require('tls');

crypto = require('crypto');

require('./buffertools');

EventEmitter = require('events').EventEmitter;

isPacketComplete = require('./packet').isPacketComplete;

packetLength = require('./packet').packetLength;

packetHeaderLength = require('./packet').HEADER_LENGTH;

Packet = require('./packet').Packet;

TYPE = require('./packet').TYPE;

StreamParser = require('./stream-parser');

ReadablePacketStream = (function (superClass) {
  extend(ReadablePacketStream, superClass);

  function ReadablePacketStream() {
    ReadablePacketStream.__super__.constructor.call(this);
  }

  ReadablePacketStream.prototype.parser = _regeneratorRuntime.mark(function callee$1$0() {
    var data, length, packetId, spid, status, type, window;
    return _regeneratorRuntime.wrap(function callee$1$0$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          if (!true) {
            context$2$0.next = 25;
            break;
          }

          context$2$0.next = 3;
          return this.readUInt8();

        case 3:
          type = context$2$0.sent;
          context$2$0.next = 6;
          return this.readUInt8();

        case 6:
          status = context$2$0.sent;
          context$2$0.next = 9;
          return this.readUInt16BE();

        case 9:
          length = context$2$0.sent;
          context$2$0.next = 12;
          return this.readUInt16BE();

        case 12:
          spid = context$2$0.sent;
          context$2$0.next = 15;
          return this.readUInt8();

        case 15:
          packetId = context$2$0.sent;
          context$2$0.next = 18;
          return this.readUInt8();

        case 18:
          window = context$2$0.sent;
          context$2$0.next = 21;
          return this.readBuffer(length - packetHeaderLength);

        case 21:
          data = context$2$0.sent;

          this.push({
            data: data,
            isLast: status & 0x01 ? function () {
              return true;
            } : function () {
              return false;
            }
          });
          context$2$0.next = 0;
          break;

        case 25:
          return context$2$0.abrupt('return', void 0);

        case 26:
        case 'end':
          return context$2$0.stop();
      }
    }, callee$1$0, this);
  });

  return ReadablePacketStream;
})(StreamParser);

MessageIO = (function (superClass) {
  extend(MessageIO, superClass);

  function MessageIO(socket, _packetSize, debug) {
    this.socket = socket;
    this._packetSize = _packetSize;
    this.debug = debug;
    this.sendPacket = bind(this.sendPacket, this);
    this.packetStream = new ReadablePacketStream();
    this.packetStream.on('data', (function (_this) {
      return function (packet) {
        _this.emit('data', packet.data);
        if (packet.isLast()) {
          return _this.emit('message');
        }
      };
    })(this));
    this.socket.pipe(this.packetStream);
    this.packetDataSize = this._packetSize - packetHeaderLength;
  }

  MessageIO.prototype.packetSize = function (packetSize) {
    if (arguments.length > 0) {
      this.debug.log("Packet size changed from " + this._packetSize + " to " + packetSize);
      this._packetSize = packetSize;
      this.packetDataSize = this._packetSize - packetHeaderLength;
    }
    return this._packetSize;
  };

  MessageIO.prototype.startTls = function (credentialsDetails) {
    var credentials;
    credentials = tls.createSecureContext ? tls.createSecureContext(credentialsDetails) : crypto.createCredentials(credentialsDetails);
    this.securePair = tls.createSecurePair(credentials);
    this.tlsNegotiationComplete = false;
    this.securePair.on('secure', (function (_this) {
      return function () {
        var cipher;
        cipher = _this.securePair.cleartext.getCipher();
        _this.debug.log("TLS negotiated (" + cipher.name + ", " + cipher.version + ")");
        _this.emit('secure', _this.securePair.cleartext);
        return _this.encryptAllFutureTraffic();
      };
    })(this));
    this.securePair.encrypted.on('data', (function (_this) {
      return function (data) {
        return _this.sendMessage(TYPE.PRELOGIN, data);
      };
    })(this));
    return this.securePair.cleartext.write('');
  };

  MessageIO.prototype.encryptAllFutureTraffic = function () {
    this.socket.unpipe(this.packetStream);
    this.securePair.encrypted.removeAllListeners('data');
    this.socket.pipe(this.securePair.encrypted);
    this.securePair.encrypted.pipe(this.socket);
    this.securePair.cleartext.pipe(this.packetStream);
    return this.tlsNegotiationComplete = true;
  };

  MessageIO.prototype.tlsHandshakeData = function (data) {
    return this.securePair.encrypted.write(data);
  };

  MessageIO.prototype.sendMessage = function (packetType, data, resetConnection) {
    var i, numberOfPackets, packet, packetNumber, packetPayload, payloadEnd, payloadStart, ref, results;
    if (data) {
      numberOfPackets = Math.floor((data.length - 1) / this.packetDataSize) + 1;
    } else {
      numberOfPackets = 1;
      data = new Buffer(0);
    }
    results = [];
    for (packetNumber = i = 0, ref = numberOfPackets - 1; 0 <= ref ? i <= ref : i >= ref; packetNumber = 0 <= ref ? ++i : --i) {
      payloadStart = packetNumber * this.packetDataSize;
      if (packetNumber < numberOfPackets - 1) {
        payloadEnd = payloadStart + this.packetDataSize;
      } else {
        payloadEnd = data.length;
      }
      packetPayload = data.slice(payloadStart, payloadEnd);
      packet = new Packet(packetType);
      packet.last(packetNumber === numberOfPackets - 1);
      packet.resetConnection(resetConnection);
      packet.packetId(packetNumber + 1);
      packet.addData(packetPayload);
      results.push(this.sendPacket(packet, packetType));
    }
    return results;
  };

  MessageIO.prototype.sendPacket = function (packet, packetType) {
    this.logPacket('Sent', packet);
    if (this.securePair && this.tlsNegotiationComplete) {
      return this.securePair.cleartext.write(packet.buffer);
    } else {
      return this.socket.write(packet.buffer);
    }
  };

  MessageIO.prototype.logPacket = function (direction, packet) {
    this.debug.packet(direction, packet);
    return this.debug.data(packet);
  };

  return MessageIO;
})(EventEmitter);

module.exports = MessageIO;